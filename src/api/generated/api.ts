/* tslint:disable */
/* eslint-disable */
/**
 * OQTOPUS Cloud User API
 * OQTOPUS Cloud User API. This API is used to interact with the OQTOPUS Cloud service. The API provides endpoints to manage devices, jobs, and results.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: oqtopus-team[at]googlegroups.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AnnouncementsGetAnnouncementResponse
 */
export interface AnnouncementsGetAnnouncementResponse {
    /**
     * 
     * @type {number}
     * @memberof AnnouncementsGetAnnouncementResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementsGetAnnouncementResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementsGetAnnouncementResponse
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementsGetAnnouncementResponse
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementsGetAnnouncementResponse
     */
    'end_time': string;
    /**
     * 
     * @type {boolean}
     * @memberof AnnouncementsGetAnnouncementResponse
     */
    'publishable': boolean;
}
/**
 * 
 * @export
 * @interface AnnouncementsGetAnnouncementsListResponse
 */
export interface AnnouncementsGetAnnouncementsListResponse {
    /**
     * 
     * @type {Array<AnnouncementsGetAnnouncementResponse>}
     * @memberof AnnouncementsGetAnnouncementsListResponse
     */
    'announcements'?: Array<AnnouncementsGetAnnouncementResponse>;
}
/**
 * 
 * @export
 * @interface ApiTokenApiToken
 */
export interface ApiTokenApiToken {
    /**
     * The api token secret
     * @type {string}
     * @memberof ApiTokenApiToken
     */
    'api_token_secret'?: string;
    /**
     * The expiration date of the api token
     * @type {string}
     * @memberof ApiTokenApiToken
     */
    'api_token_expiration'?: string;
}
/**
 * 
 * @export
 * @interface DevicesDeviceInfo
 */
export interface DevicesDeviceInfo {
    /**
     * 
     * @type {string}
     * @memberof DevicesDeviceInfo
     */
    'device_id': string;
    /**
     * 
     * @type {string}
     * @memberof DevicesDeviceInfo
     */
    'device_type': DevicesDeviceInfoDeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DevicesDeviceInfo
     */
    'status': DevicesDeviceInfoStatusEnum;
    /**
     * Parameter mandatory and valid for \'unavailable\' devices
     * @type {string}
     * @memberof DevicesDeviceInfo
     */
    'available_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof DevicesDeviceInfo
     */
    'n_pending_jobs': number;
    /**
     * 
     * @type {number}
     * @memberof DevicesDeviceInfo
     */
    'n_qubits'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DevicesDeviceInfo
     */
    'basis_gates': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DevicesDeviceInfo
     */
    'supported_instructions': Array<string>;
    /**
     * json format calibration_data and n_nodes etc
     * @type {string}
     * @memberof DevicesDeviceInfo
     */
    'device_info'?: string;
    /**
     * Parameter available only for `QPU` devices with available calibration data
     * @type {string}
     * @memberof DevicesDeviceInfo
     */
    'calibrated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DevicesDeviceInfo
     */
    'description': string;
}

export const DevicesDeviceInfoDeviceTypeEnum = {
    Qpu: 'QPU',
    Simulator: 'simulator'
} as const;

export type DevicesDeviceInfoDeviceTypeEnum = typeof DevicesDeviceInfoDeviceTypeEnum[keyof typeof DevicesDeviceInfoDeviceTypeEnum];
export const DevicesDeviceInfoStatusEnum = {
    Available: 'available',
    Unavailable: 'unavailable'
} as const;

export type DevicesDeviceInfoStatusEnum = typeof DevicesDeviceInfoStatusEnum[keyof typeof DevicesDeviceInfoStatusEnum];

/**
 * 
 * @export
 * @interface ErrorBadRequest
 */
export interface ErrorBadRequest {
    /**
     * 
     * @type {string}
     * @memberof ErrorBadRequest
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ErrorForbiddenError
 */
export interface ErrorForbiddenError {
    /**
     * 
     * @type {string}
     * @memberof ErrorForbiddenError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ErrorInternalServerError
 */
export interface ErrorInternalServerError {
    /**
     * 
     * @type {string}
     * @memberof ErrorInternalServerError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ErrorNotFoundError
 */
export interface ErrorNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ErrorNotFoundError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ErrorUnauthorizedError
 */
export interface ErrorUnauthorizedError {
    /**
     * 
     * @type {string}
     * @memberof ErrorUnauthorizedError
     */
    'message': string;
}
/**
 * @type GetJob200Response
 * @export
 */
export type GetJob200Response = JobsRegisteredJob | JobsSubmittedJob;

/**
 * job status
 * @export
 * @interface JobsGetJobStatusResponse
 */
export interface JobsGetJobStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof JobsGetJobStatusResponse
     */
    'job_id': string;
    /**
     * 
     * @type {JobsJobStatus}
     * @memberof JobsGetJobStatusResponse
     */
    'status': JobsJobStatus;
}


/**
 * 
 * @export
 * @interface JobsJobBase
 */
export interface JobsJobBase {
    /**
     * 
     * @type {string}
     * @memberof JobsJobBase
     */
    'job_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobBase
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobBase
     */
    'description'?: string;
    /**
     * 
     * @type {JobsJobType}
     * @memberof JobsJobBase
     */
    'job_type'?: JobsJobType;
    /**
     * 
     * @type {JobsJobStatus}
     * @memberof JobsJobBase
     */
    'status'?: JobsJobStatus;
    /**
     * 
     * @type {string}
     * @memberof JobsJobBase
     */
    'device_id'?: string;
    /**
     * 0 is valid only for newly registered job_ids (job status=registered)
     * @type {number}
     * @memberof JobsJobBase
     */
    'shots'?: number;
    /**
     * 
     * @type {JobsJobInfo}
     * @memberof JobsJobBase
     */
    'job_info'?: JobsJobInfo;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsJobBase
     */
    'transpiler_info'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsJobBase
     */
    'simulator_info'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsJobBase
     */
    'mitigation_info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof JobsJobBase
     */
    'execution_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobsJobBase
     */
    'submitted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobBase
     */
    'ready_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobBase
     */
    'running_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobBase
     */
    'ended_at'?: string;
}


/**
 * Presigned URLs for downloading relevant job information .zip files from OQTOPUS cloud.
 * @export
 * @interface JobsJobInfo
 */
export interface JobsJobInfo {
    /**
     * Content of the file will match `jobs.S3SubmitJobInfo` schema.
     * @type {string}
     * @memberof JobsJobInfo
     */
    'input': string;
    /**
     * For multiprogramming jobs, this file contains the combined circuit.
     * @type {string}
     * @memberof JobsJobInfo
     */
    'combined_program'?: string;
    /**
     * Content of the file will match `jobs.S3JobResult` schema.
     * @type {string}
     * @memberof JobsJobInfo
     */
    'result'?: string;
    /**
     * Content of the file will match `jobs.S3TranspileResult` schema.
     * @type {string}
     * @memberof JobsJobInfo
     */
    'transpile_result'?: string;
    /**
     * File available only for sse jobs.
     * @type {string}
     * @memberof JobsJobInfo
     */
    'sse_log'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobInfo
     */
    'message'?: string;
}
/**
 * Presigned URL for uploading file to OCTOPUS cloud.
 * @export
 * @interface JobsJobInfoUploadPresignedURL
 */
export interface JobsJobInfoUploadPresignedURL {
    /**
     * 
     * @type {string}
     * @memberof JobsJobInfoUploadPresignedURL
     */
    'url'?: string;
    /**
     * 
     * @type {JobsJobInfoUploadPresignedURLFields}
     * @memberof JobsJobInfoUploadPresignedURL
     */
    'fields'?: JobsJobInfoUploadPresignedURLFields;
}
/**
 * 
 * @export
 * @interface JobsJobInfoUploadPresignedURLFields
 */
export interface JobsJobInfoUploadPresignedURLFields {
    /**
     * 
     * @type {string}
     * @memberof JobsJobInfoUploadPresignedURLFields
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobInfoUploadPresignedURLFields
     */
    'AWSAccessKeyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobInfoUploadPresignedURLFields
     */
    'x-amz-security-token'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobInfoUploadPresignedURLFields
     */
    'policy'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsJobInfoUploadPresignedURLFields
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobsJobStatus = {
    Registered: 'registered',
    Submitted: 'submitted',
    Ready: 'ready',
    Running: 'running',
    Succeeded: 'succeeded',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;

export type JobsJobStatus = typeof JobsJobStatus[keyof typeof JobsJobStatus];


/**
 * none is valid only for newly registered job_ids (job status=registered)
 * @export
 * @enum {string}
 */

export const JobsJobType = {
    None: 'none',
    Estimation: 'estimation',
    Sampling: 'sampling',
    MultiManual: 'multi_manual',
    Sse: 'sse'
} as const;

export type JobsJobType = typeof JobsJobType[keyof typeof JobsJobType];


/**
 * Register new job
 * @export
 * @interface JobsRegisterJobResponse
 */
export interface JobsRegisterJobResponse {
    /**
     * 
     * @type {string}
     * @memberof JobsRegisterJobResponse
     */
    'job_id': string;
    /**
     * 
     * @type {JobsJobInfoUploadPresignedURL}
     * @memberof JobsRegisterJobResponse
     */
    'presigned_url': JobsJobInfoUploadPresignedURL;
}
/**
 * 
 * @export
 * @interface JobsRegisteredJob
 */
export interface JobsRegisteredJob {
    /**
     * 
     * @type {string}
     * @memberof JobsRegisteredJob
     */
    'job_id': string;
    /**
     * 
     * @type {string}
     * @memberof JobsRegisteredJob
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsRegisteredJob
     */
    'description'?: string;
    /**
     * 
     * @type {JobsJobType}
     * @memberof JobsRegisteredJob
     */
    'job_type'?: JobsJobType;
    /**
     * 
     * @type {JobsJobStatus}
     * @memberof JobsRegisteredJob
     */
    'status': JobsJobStatus;
    /**
     * 
     * @type {string}
     * @memberof JobsRegisteredJob
     */
    'device_id'?: string;
    /**
     * 0 is valid only for newly registered job_ids (job status=registered)
     * @type {number}
     * @memberof JobsRegisteredJob
     */
    'shots'?: number;
    /**
     * 
     * @type {JobsJobInfo}
     * @memberof JobsRegisteredJob
     */
    'job_info'?: JobsJobInfo;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsRegisteredJob
     */
    'transpiler_info'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsRegisteredJob
     */
    'simulator_info'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsRegisteredJob
     */
    'mitigation_info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof JobsRegisteredJob
     */
    'execution_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobsRegisteredJob
     */
    'submitted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsRegisteredJob
     */
    'ready_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsRegisteredJob
     */
    'running_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsRegisteredJob
     */
    'ended_at'?: string;
}


/**
 * *(Only for estimation jobs)* The estimated expectation value and the standard deviation of the operators specified in `job_info.operator` field which is intended to be provided for estimation jobs. 
 * @export
 * @interface JobsS3EstimationResult
 */
export interface JobsS3EstimationResult {
    /**
     * The estimated expectation value
     * @type {number}
     * @memberof JobsS3EstimationResult
     */
    'exp_value'?: number;
    /**
     * The standard deviation value
     * @type {number}
     * @memberof JobsS3EstimationResult
     */
    'stds'?: number;
}
/**
 * 
 * @export
 * @interface JobsS3JobResult
 */
export interface JobsS3JobResult {
    [key: string]: any;

    /**
     * 
     * @type {JobsS3SamplingResult}
     * @memberof JobsS3JobResult
     */
    'sampling'?: JobsS3SamplingResult;
    /**
     * 
     * @type {JobsS3EstimationResult}
     * @memberof JobsS3JobResult
     */
    'estimation'?: JobsS3EstimationResult;
}
/**
 * 
 * @export
 * @interface JobsS3OperatorItem
 */
export interface JobsS3OperatorItem {
    /**
     * The Pauli string.
     * @type {string}
     * @memberof JobsS3OperatorItem
     */
    'pauli': string;
    /**
     * Coefficient number in the Pauli string representation.
     * @type {number}
     * @memberof JobsS3OperatorItem
     */
    'coeff'?: number;
}
/**
 * *(Only for sampling jobs)* JSON string representing the sampling result
 * @export
 * @interface JobsS3SamplingResult
 */
export interface JobsS3SamplingResult {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsS3SamplingResult
     */
    'counts'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsS3SamplingResult
     */
    'divided_counts'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface JobsS3SubmitJobInfo
 */
export interface JobsS3SubmitJobInfo {
    /**
     * A list of OPENQASM3 program. For non-multiprogramming jobs, this field is assumed to contain exactly one program. Otherwise, those programs are combined according to the multiprogramming machinery.
     * @type {Array<string>}
     * @memberof JobsS3SubmitJobInfo
     */
    'program': Array<string>;
    /**
     * 
     * @type {Array<JobsS3OperatorItem>}
     * @memberof JobsS3SubmitJobInfo
     */
    'operator'?: Array<JobsS3OperatorItem>;
}
/**
 * 
 * @export
 * @interface JobsS3TranspileResult
 */
export interface JobsS3TranspileResult {
    /**
     * 
     * @type {string}
     * @memberof JobsS3TranspileResult
     */
    'transpiled_program': string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsS3TranspileResult
     */
    'stats': { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsS3TranspileResult
     */
    'virtual_physical_mapping': { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface JobsSubmitJobRequest
 */
export interface JobsSubmitJobRequest {
    /**
     * 
     * @type {string}
     * @memberof JobsSubmitJobRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsSubmitJobRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsSubmitJobRequest
     */
    'device_id': string;
    /**
     * 
     * @type {JobsSubmitJobType}
     * @memberof JobsSubmitJobRequest
     */
    'job_type': JobsSubmitJobType;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsSubmitJobRequest
     */
    'transpiler_info'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsSubmitJobRequest
     */
    'simulator_info'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsSubmitJobRequest
     */
    'mitigation_info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof JobsSubmitJobRequest
     */
    'shots': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const JobsSubmitJobType = {
    Estimation: 'estimation',
    Sampling: 'sampling',
    MultiManual: 'multi_manual',
    Sse: 'sse'
} as const;

export type JobsSubmitJobType = typeof JobsSubmitJobType[keyof typeof JobsSubmitJobType];


/**
 * 
 * @export
 * @interface JobsSubmittedJob
 */
export interface JobsSubmittedJob {
    /**
     * 
     * @type {string}
     * @memberof JobsSubmittedJob
     */
    'job_id': string;
    /**
     * 
     * @type {string}
     * @memberof JobsSubmittedJob
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof JobsSubmittedJob
     */
    'description'?: string;
    /**
     * 
     * @type {JobsJobType}
     * @memberof JobsSubmittedJob
     */
    'job_type': JobsJobType;
    /**
     * 
     * @type {JobsJobStatus}
     * @memberof JobsSubmittedJob
     */
    'status': JobsJobStatus;
    /**
     * 
     * @type {string}
     * @memberof JobsSubmittedJob
     */
    'device_id': string;
    /**
     * 0 is valid only for newly registered job_ids (job status=registered)
     * @type {number}
     * @memberof JobsSubmittedJob
     */
    'shots': number;
    /**
     * 
     * @type {JobsJobInfo}
     * @memberof JobsSubmittedJob
     */
    'job_info': JobsJobInfo;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsSubmittedJob
     */
    'transpiler_info'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsSubmittedJob
     */
    'simulator_info'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobsSubmittedJob
     */
    'mitigation_info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof JobsSubmittedJob
     */
    'execution_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobsSubmittedJob
     */
    'submitted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsSubmittedJob
     */
    'ready_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsSubmittedJob
     */
    'running_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobsSubmittedJob
     */
    'ended_at'?: string;
}
/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get selected announcement
         * @summary Get selected announcement
         * @param {number} announcementId announcement ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement: async (announcementId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'announcementId' is not null or undefined
            assertParamExists('getAnnouncement', 'announcementId', announcementId)
            const localVarPath = `/announcements/{announcement_id}`
                .replace(`{${"announcement_id"}}`, encodeURIComponent(String(announcementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get announcements list from backend
         * @summary Get announcements list from backend
         * @param {string} [offset] offset information
         * @param {string} [limit] Limit information
         * @param {GetAnnouncementsListOrderEnum} [order] Specify order according to start time
         * @param {string} [currentTime] Allows to filter the list of announcements to fetch by provided time. If specified only announcements with start_time &lt;&#x3D; current_time and end_time &gt;&#x3D; current_time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementsList: async (offset?: string, limit?: string, order?: GetAnnouncementsListOrderEnum, currentTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (currentTime !== undefined) {
                localVarQueryParameter['current_time'] = (currentTime as any instanceof Date) ?
                    (currentTime as any).toISOString() :
                    currentTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get selected announcement
         * @summary Get selected announcement
         * @param {number} announcementId announcement ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncement(announcementId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementsGetAnnouncementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncement(announcementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnouncementsApi.getAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get announcements list from backend
         * @summary Get announcements list from backend
         * @param {string} [offset] offset information
         * @param {string} [limit] Limit information
         * @param {GetAnnouncementsListOrderEnum} [order] Specify order according to start time
         * @param {string} [currentTime] Allows to filter the list of announcements to fetch by provided time. If specified only announcements with start_time &lt;&#x3D; current_time and end_time &gt;&#x3D; current_time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnouncementsList(offset?: string, limit?: string, order?: GetAnnouncementsListOrderEnum, currentTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementsGetAnnouncementsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnouncementsList(offset, limit, order, currentTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnouncementsApi.getAnnouncementsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnouncementsApiFp(configuration)
    return {
        /**
         * Get selected announcement
         * @summary Get selected announcement
         * @param {number} announcementId announcement ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncement(announcementId: number, options?: RawAxiosRequestConfig): AxiosPromise<AnnouncementsGetAnnouncementResponse> {
            return localVarFp.getAnnouncement(announcementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get announcements list from backend
         * @summary Get announcements list from backend
         * @param {string} [offset] offset information
         * @param {string} [limit] Limit information
         * @param {GetAnnouncementsListOrderEnum} [order] Specify order according to start time
         * @param {string} [currentTime] Allows to filter the list of announcements to fetch by provided time. If specified only announcements with start_time &lt;&#x3D; current_time and end_time &gt;&#x3D; current_time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnouncementsList(offset?: string, limit?: string, order?: GetAnnouncementsListOrderEnum, currentTime?: string, options?: RawAxiosRequestConfig): AxiosPromise<AnnouncementsGetAnnouncementsListResponse> {
            return localVarFp.getAnnouncementsList(offset, limit, order, currentTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
    /**
     * Get selected announcement
     * @summary Get selected announcement
     * @param {number} announcementId announcement ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public getAnnouncement(announcementId: number, options?: RawAxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).getAnnouncement(announcementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get announcements list from backend
     * @summary Get announcements list from backend
     * @param {string} [offset] offset information
     * @param {string} [limit] Limit information
     * @param {GetAnnouncementsListOrderEnum} [order] Specify order according to start time
     * @param {string} [currentTime] Allows to filter the list of announcements to fetch by provided time. If specified only announcements with start_time &lt;&#x3D; current_time and end_time &gt;&#x3D; current_time are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public getAnnouncementsList(offset?: string, limit?: string, order?: GetAnnouncementsListOrderEnum, currentTime?: string, options?: RawAxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).getAnnouncementsList(offset, limit, order, currentTime, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAnnouncementsListOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;
export type GetAnnouncementsListOrderEnum = typeof GetAnnouncementsListOrderEnum[keyof typeof GetAnnouncementsListOrderEnum];


/**
 * 
 * @export
 * @interface SuccessSuccessResponse
 */
export interface SuccessSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof SuccessSuccessResponse
     */
    'message': string;
}

/**
 * ApiTokenApi - axios parameter creator
 * @export
 */
export const ApiTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create api token
         * @summary create api token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete api token
         * @summary delete api token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get api token
         * @summary get api token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiTokenApi - functional programming interface
 * @export
 */
export const ApiTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Create api token
         * @summary create api token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTokenApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiTokenApi.createApiToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete api token
         * @summary delete api token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiTokenApi.deleteApiToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get api token
         * @summary get api token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTokenApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiTokenApi.getApiToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiTokenApi - factory interface
 * @export
 */
export const ApiTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiTokenApiFp(configuration)
    return {
        /**
         * Create api token
         * @summary create api token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiToken(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiTokenApiToken>> {
            return localVarFp.createApiToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete api token
         * @summary delete api token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiToken(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApiToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Get api token
         * @summary get api token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiToken(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiTokenApiToken>> {
            return localVarFp.getApiToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiTokenApi - object-oriented interface
 * @export
 * @class ApiTokenApi
 * @extends {BaseAPI}
 */
export class ApiTokenApi extends BaseAPI {
    /**
     * Create api token
     * @summary create api token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiTokenApi
     */
    public createApiToken(options?: RawAxiosRequestConfig) {
        return ApiTokenApiFp(this.configuration).createApiToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete api token
     * @summary delete api token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiTokenApi
     */
    public deleteApiToken(options?: RawAxiosRequestConfig) {
        return ApiTokenApiFp(this.configuration).deleteApiToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get api token
     * @summary get api token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiTokenApi
     */
    public getApiToken(options?: RawAxiosRequestConfig) {
        return ApiTokenApiFp(this.configuration).getApiToken(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeviceApi - axios parameter creator
 * @export
 */
export const DeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get device
         * @summary Get specified device details
         * @param {string} deviceId Device identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (deviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getDevice', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available devices
         * @summary List available devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceApiAxiosParamCreator(configuration)
    return {
        /**
         * get device
         * @summary Get specified device details
         * @param {string} deviceId Device identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(deviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DevicesDeviceInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.getDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List available devices
         * @summary List available devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDevices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DevicesDeviceInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDevices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.listDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceApiFp(configuration)
    return {
        /**
         * get device
         * @summary Get specified device details
         * @param {string} deviceId Device identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<DevicesDeviceInfo> {
            return localVarFp.getDevice(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List available devices
         * @summary List available devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevices(options?: RawAxiosRequestConfig): AxiosPromise<Array<DevicesDeviceInfo>> {
            return localVarFp.listDevices(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI {
    /**
     * get device
     * @summary Get specified device details
     * @param {string} deviceId Device identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getDevice(deviceId: string, options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).getDevice(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available devices
     * @summary List available devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public listDevices(options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).listDevices(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Start a procedure to cancel quantum job.<br/><br/> Operation is valid only for job with status: submitted, ready or running.
         * @summary Cancel job
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cancelJob', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/cancel`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes quantum job and related result<br/><br/>Operation is valid only for job with status: succeeded, failed and cancelled. submitted, ready and running jobs must be cancelled before deletion.
         * @summary Delete job
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJob', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get selected job
         * @summary Get selected job
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJob', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get selected job\'s status
         * @summary Get selected job\'s status
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobStatus', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/status`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, all available job\'s properties are returned. Use \'fields\' parameter to specify exact list of properties to get for each job.  List of jobs can be filtered by job creation time or search text with \'start_time\', \'end_time\' and \'q\' parameters.  Jobs are fetched with the pagination mechanism. This can be configured with \'page\' and \'perPage\' parameters. Check response\'s \'Link\' header for pagination details.
         * @summary List all quantum jobs
         * @param {string} [fields] Allows to specify an exact list of job properties to fetch for a single job. Each element of the list must be a valid name of job property.  If parameter is specified and requested job field is not defined for a job null is returned.  If parameter is omitted all available job properties are returned. Undefined job properties (null properties) are not included in the response.
         * @param {string} [startTime] Allows to filter the list of jobs to fetch by creation time. If specified only jobs with creation time  (createdAt property) &gt;&#x3D; start_time are returned.
         * @param {string} [endTiime] Allows to filter the list of jobs to fetch by to creation time. If specified only jobs with creation time (createdAt property) &lt;&#x3D; end_time are returned.
         * @param {string} [q] Allows to filter the list of jobs to fetch by job\&#39;s name and description. If specified only jobs which name or description contains specified search string are returned.
         * @param {number} [page] Set jobs list page number to fetch. If requested page number exceeds number of all pages last page is returned.
         * @param {number} [size] Configure number of jobs per page
         * @param {ListJobsOrderEnum} [order] Specify jobs order according to creation time (createdAt property)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (fields?: string, startTime?: string, endTiime?: string, q?: string, page?: number, size?: number, order?: ListJobsOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTiime !== undefined) {
                localVarQueryParameter['end_tiime'] = (endTiime as any instanceof Date) ?
                    (endTiime as any).toISOString() :
                    endTiime;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register new job and generate a presigned URL to upload job information (`jobs.S3SubmitJobInfo`) to OQTOPUS cloud.
         * @summary Register new job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerJobId: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete submission of a previously registered quantum job.  job_id must be created via \'POST /jobs\' request.  Submit job information (`jobs.S3SubmitJobInfo`) must be formerly uploaded to OQTOPUS cloud using presigned URL received in \'POST /jobs\' response.
         * @summary Complete submission of a quantum job
         * @param {string} jobId Job identifier
         * @param {JobsSubmitJobRequest} [jobsSubmitJobRequest] Quantum job to be submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitJob: async (jobId: string, jobsSubmitJobRequest?: JobsSubmitJobRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('submitJob', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/submit`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobsSubmitJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * Start a procedure to cancel quantum job.<br/><br/> Operation is valid only for job with status: submitted, ready or running.
         * @summary Cancel job
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.cancelJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes quantum job and related result<br/><br/>Operation is valid only for job with status: succeeded, failed and cancelled. submitted, ready and running jobs must be cancelled before deletion.
         * @summary Delete job
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.deleteJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get selected job
         * @summary Get selected job
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.getJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get selected job\'s status
         * @summary Get selected job\'s status
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobStatus(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobsGetJobStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatus(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.getJobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * By default, all available job\'s properties are returned. Use \'fields\' parameter to specify exact list of properties to get for each job.  List of jobs can be filtered by job creation time or search text with \'start_time\', \'end_time\' and \'q\' parameters.  Jobs are fetched with the pagination mechanism. This can be configured with \'page\' and \'perPage\' parameters. Check response\'s \'Link\' header for pagination details.
         * @summary List all quantum jobs
         * @param {string} [fields] Allows to specify an exact list of job properties to fetch for a single job. Each element of the list must be a valid name of job property.  If parameter is specified and requested job field is not defined for a job null is returned.  If parameter is omitted all available job properties are returned. Undefined job properties (null properties) are not included in the response.
         * @param {string} [startTime] Allows to filter the list of jobs to fetch by creation time. If specified only jobs with creation time  (createdAt property) &gt;&#x3D; start_time are returned.
         * @param {string} [endTiime] Allows to filter the list of jobs to fetch by to creation time. If specified only jobs with creation time (createdAt property) &lt;&#x3D; end_time are returned.
         * @param {string} [q] Allows to filter the list of jobs to fetch by job\&#39;s name and description. If specified only jobs which name or description contains specified search string are returned.
         * @param {number} [page] Set jobs list page number to fetch. If requested page number exceeds number of all pages last page is returned.
         * @param {number} [size] Configure number of jobs per page
         * @param {ListJobsOrderEnum} [order] Specify jobs order according to creation time (createdAt property)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(fields?: string, startTime?: string, endTiime?: string, q?: string, page?: number, size?: number, order?: ListJobsOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<JobsJobBase>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(fields, startTime, endTiime, q, page, size, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.listJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register new job and generate a presigned URL to upload job information (`jobs.S3SubmitJobInfo`) to OQTOPUS cloud.
         * @summary Register new job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerJobId(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobsRegisterJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerJobId(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.registerJobId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete submission of a previously registered quantum job.  job_id must be created via \'POST /jobs\' request.  Submit job information (`jobs.S3SubmitJobInfo`) must be formerly uploaded to OQTOPUS cloud using presigned URL received in \'POST /jobs\' response.
         * @summary Complete submission of a quantum job
         * @param {string} jobId Job identifier
         * @param {JobsSubmitJobRequest} [jobsSubmitJobRequest] Quantum job to be submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitJob(jobId: string, jobsSubmitJobRequest?: JobsSubmitJobRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitJob(jobId, jobsSubmitJobRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.submitJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * Start a procedure to cancel quantum job.<br/><br/> Operation is valid only for job with status: submitted, ready or running.
         * @summary Cancel job
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessSuccessResponse> {
            return localVarFp.cancelJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes quantum job and related result<br/><br/>Operation is valid only for job with status: succeeded, failed and cancelled. submitted, ready and running jobs must be cancelled before deletion.
         * @summary Delete job
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessSuccessResponse> {
            return localVarFp.deleteJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get selected job
         * @summary Get selected job
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetJob200Response> {
            return localVarFp.getJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get selected job\'s status
         * @summary Get selected job\'s status
         * @param {string} jobId Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobsGetJobStatusResponse> {
            return localVarFp.getJobStatus(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, all available job\'s properties are returned. Use \'fields\' parameter to specify exact list of properties to get for each job.  List of jobs can be filtered by job creation time or search text with \'start_time\', \'end_time\' and \'q\' parameters.  Jobs are fetched with the pagination mechanism. This can be configured with \'page\' and \'perPage\' parameters. Check response\'s \'Link\' header for pagination details.
         * @summary List all quantum jobs
         * @param {string} [fields] Allows to specify an exact list of job properties to fetch for a single job. Each element of the list must be a valid name of job property.  If parameter is specified and requested job field is not defined for a job null is returned.  If parameter is omitted all available job properties are returned. Undefined job properties (null properties) are not included in the response.
         * @param {string} [startTime] Allows to filter the list of jobs to fetch by creation time. If specified only jobs with creation time  (createdAt property) &gt;&#x3D; start_time are returned.
         * @param {string} [endTiime] Allows to filter the list of jobs to fetch by to creation time. If specified only jobs with creation time (createdAt property) &lt;&#x3D; end_time are returned.
         * @param {string} [q] Allows to filter the list of jobs to fetch by job\&#39;s name and description. If specified only jobs which name or description contains specified search string are returned.
         * @param {number} [page] Set jobs list page number to fetch. If requested page number exceeds number of all pages last page is returned.
         * @param {number} [size] Configure number of jobs per page
         * @param {ListJobsOrderEnum} [order] Specify jobs order according to creation time (createdAt property)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(fields?: string, startTime?: string, endTiime?: string, q?: string, page?: number, size?: number, order?: ListJobsOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<JobsJobBase>> {
            return localVarFp.listJobs(fields, startTime, endTiime, q, page, size, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Register new job and generate a presigned URL to upload job information (`jobs.S3SubmitJobInfo`) to OQTOPUS cloud.
         * @summary Register new job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerJobId(options?: RawAxiosRequestConfig): AxiosPromise<JobsRegisterJobResponse> {
            return localVarFp.registerJobId(options).then((request) => request(axios, basePath));
        },
        /**
         * Complete submission of a previously registered quantum job.  job_id must be created via \'POST /jobs\' request.  Submit job information (`jobs.S3SubmitJobInfo`) must be formerly uploaded to OQTOPUS cloud using presigned URL received in \'POST /jobs\' response.
         * @summary Complete submission of a quantum job
         * @param {string} jobId Job identifier
         * @param {JobsSubmitJobRequest} [jobsSubmitJobRequest] Quantum job to be submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitJob(jobId: string, jobsSubmitJobRequest?: JobsSubmitJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessSuccessResponse> {
            return localVarFp.submitJob(jobId, jobsSubmitJobRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * Start a procedure to cancel quantum job.<br/><br/> Operation is valid only for job with status: submitted, ready or running.
     * @summary Cancel job
     * @param {string} jobId Job identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public cancelJob(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).cancelJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes quantum job and related result<br/><br/>Operation is valid only for job with status: succeeded, failed and cancelled. submitted, ready and running jobs must be cancelled before deletion.
     * @summary Delete job
     * @param {string} jobId Job identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public deleteJob(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).deleteJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get selected job
     * @summary Get selected job
     * @param {string} jobId Job identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getJob(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get selected job\'s status
     * @summary Get selected job\'s status
     * @param {string} jobId Job identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getJobStatus(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getJobStatus(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, all available job\'s properties are returned. Use \'fields\' parameter to specify exact list of properties to get for each job.  List of jobs can be filtered by job creation time or search text with \'start_time\', \'end_time\' and \'q\' parameters.  Jobs are fetched with the pagination mechanism. This can be configured with \'page\' and \'perPage\' parameters. Check response\'s \'Link\' header for pagination details.
     * @summary List all quantum jobs
     * @param {string} [fields] Allows to specify an exact list of job properties to fetch for a single job. Each element of the list must be a valid name of job property.  If parameter is specified and requested job field is not defined for a job null is returned.  If parameter is omitted all available job properties are returned. Undefined job properties (null properties) are not included in the response.
     * @param {string} [startTime] Allows to filter the list of jobs to fetch by creation time. If specified only jobs with creation time  (createdAt property) &gt;&#x3D; start_time are returned.
     * @param {string} [endTiime] Allows to filter the list of jobs to fetch by to creation time. If specified only jobs with creation time (createdAt property) &lt;&#x3D; end_time are returned.
     * @param {string} [q] Allows to filter the list of jobs to fetch by job\&#39;s name and description. If specified only jobs which name or description contains specified search string are returned.
     * @param {number} [page] Set jobs list page number to fetch. If requested page number exceeds number of all pages last page is returned.
     * @param {number} [size] Configure number of jobs per page
     * @param {ListJobsOrderEnum} [order] Specify jobs order according to creation time (createdAt property)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public listJobs(fields?: string, startTime?: string, endTiime?: string, q?: string, page?: number, size?: number, order?: ListJobsOrderEnum, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).listJobs(fields, startTime, endTiime, q, page, size, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register new job and generate a presigned URL to upload job information (`jobs.S3SubmitJobInfo`) to OQTOPUS cloud.
     * @summary Register new job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public registerJobId(options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).registerJobId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete submission of a previously registered quantum job.  job_id must be created via \'POST /jobs\' request.  Submit job information (`jobs.S3SubmitJobInfo`) must be formerly uploaded to OQTOPUS cloud using presigned URL received in \'POST /jobs\' response.
     * @summary Complete submission of a quantum job
     * @param {string} jobId Job identifier
     * @param {JobsSubmitJobRequest} [jobsSubmitJobRequest] Quantum job to be submitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public submitJob(jobId: string, jobsSubmitJobRequest?: JobsSubmitJobRequest, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).submitJob(jobId, jobsSubmitJobRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListJobsOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;
export type ListJobsOrderEnum = typeof ListJobsOrderEnum[keyof typeof ListJobsOrderEnum];


